% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/importRecords.R
\name{importRecords}
\alias{importRecords}
\alias{importRecords.redcapApiConnection}
\title{Import Records to a Project}
\usage{
importRecords(
  rcon,
  data,
  overwrite_behavior = c("normal", "overwrite"),
  return_content = c("count", "ids", "nothing", "auto_ids"),
  force_auto_number = FALSE,
  ...
)

\method{importRecords}{redcapApiConnection}(
  rcon,
  data,
  overwrite_behavior = c("normal", "overwrite"),
  return_content = c("count", "ids", "nothing", "auto_ids"),
  force_auto_number = FALSE,
  ...,
  na = list(),
  validation = list(),
  cast = list(),
  skip_import = FALSE,
  batch_size = NULL,
  error_handling = getOption("redcap_error_handling"),
  config = list(),
  api_param = list()
)
}
\arguments{
\item{rcon}{A \code{redcapConnection} object.}

\item{data}{\code{data.frame}. The data to be imported to the project.}

\item{overwrite_behavior}{\code{character(1)}. One of \code{c("normal", "overwrite")}.
\code{"normal"} prevents blank fields from overwriting populated fields.
\code{"overwrite"} causes blanks to overwrite data in the database.}

\item{return_content}{\code{character(1)}.
One of \code{c("count", "ids", "nothing", "auto_ids")}.
'count' returns the number of records imported;
'ids' returns the record ids that are imported;
'nothing' returns no message;
'auto_ids' returns a list of pairs of all record IDs that were imported.
If used when \code{force_auto_number = FALSE}, the value will be changed to \code{'ids'}.}

\item{force_auto_number}{\code{logical(1)}. If record auto-numbering has been
enabled in the project, it may be desirable to import records where each
record's record name is automatically determined by REDCap (just as it
does in the user interface). When \code{TRUE}, the
record names provided in the request will not be used (although they
are still required in order to associate multiple rows of data to an
individual record in the request); instead those records in the
request will receive new record names during the import process.
It is recommended that the user use \code{return_content = "auto_ids"}
when \code{force_auto_number = TRUE}}

\item{...}{Arguments to pass to other methods}

\item{na}{A named \code{list} of user specified functions to determine if the
data is NA. This is useful when data is loaded that has coding for NA, e.g.
-5 is NA. Keys must correspond to a truncated REDCap field type, i.e.
{date_, datetime_, datetime_seconds_, time_mm_ss, time_hh_mm_ss, time, float,
number, calc, int, integer, select, radio, dropdown, yesno, truefalse,
checkbox, form_complete, sql, system}. The function will be provided the
variables (x, field_name, coding). The function must return a vector of
logicals matching the input. It defaults to \code{\link[=isNAorBlank]{isNAorBlank()}} for all
entries.}

\item{validation}{A named \code{list} of user specified validation functions. The
same named keys are supported as the na argument. The function will be
provided the variables (x, field_name, coding). The function must return a
vector of logical matching the input length. Helper functions to construct
these are \code{\link[=valRx]{valRx()}} and \code{\link[=valChoice]{valChoice()}}. Only fields that
are not identified as NA will be passed to validation functions.}

\item{cast}{A named \code{list} of user specified class casting functions. The
same named keys are supported as the na argument. The function will be
provided the variables (x, field_name, coding). The function must return a
vector of logical matching the input length. See \code{\link[=fieldValidationAndCasting]{fieldValidationAndCasting()}}}

\item{skip_import}{\code{logical(1)}. When \code{TRUE}, the data will undergo validation
and casting, but will not be sent to the project. This permits the user
to obtain and review the data before attempting to import it.}

\item{batch_size}{\code{integerish(1)}.  Specifies the number of subjects to be included
in each batch of a batched export or import.  Non-positive numbers
export/import the entire operation in a single batch.
Batching may be beneficial to prevent tying up smaller servers.
See Details.}

\item{error_handling}{\code{character(1)}. One of \code{c("error", "null")}.
An option for how to handle errors returned by the API.
see \code{\link[=redcapError]{redcapError()}}.}

\item{config}{A named \code{list}. Additional configuration parameters to pass to
\code{\link[httr:POST]{httr::POST()}}. These are appended to any parameters in
\code{rcon$config}.}

\item{api_param}{A named \code{list}. Additional API parameters to pass into the
body of the API call. This provides users to execute calls with options
that may not otherwise be supported by \code{redcapAPI}.}
}
\value{
Returns a data frame with the data after having been passed through
\code{castForImport}.

The data frame has an attribute \code{return_content} that gives the content
returned by the API.
}
\description{
These methods enable the user to import new records or update
existing records to a project.
}
\details{
A 'batched' import is one where the export is performed over a series of
API calls rather than one large call.  For large projects on small servers,
this may prevent a single user from tying up the server and forcing others
to wait on a larger job.
\subsection{BioPortal Fields}{

Text fields that are validation enabled using the BioPortal Ontology service
may be imported by providing the coded value. Importing the coded value
does not, however, guarantee that the labeled value will be immediately
available. Labels for BioPortal values are cached on the REDCap server
in a process that occurs when viewing data in the user interface. Thus,
if the label has not be previously cached on the server, the code will be
used to represent both the code and the label.
}
}
\examples{
\dontrun{
unlockREDCap(connections = c(rcon = "project_alias"), 
             url = "your_redcap_url", 
             keyring = "API_KEYs", 
             envir = globalenv())

# Import records
NewData <- data.frame(record_id = c(1, 2, 3), 
                      age = c(27, 43, 32), 
                      date_of_visit = rep(Sys.Date(), 3))
importRecords(rcon, 
              data = NewData)
              
              
# Import records using auto numbering
NewData <- data.frame(record_id = c(1, 2, 3), 
                      age = c(27, 43, 32), 
                      date_of_visit = rep(Sys.Date(), 3))
importRecords(rcon, 
              data = NewData,
              force_auto_number = TRUE)
              

} 

}
\seealso{
\code{\link[=exportRecords]{exportRecords()}}, \cr
\code{\link[=deleteRecords]{deleteRecords()}}, \cr
\code{\link[=exportRecordsTyped]{exportRecordsTyped()}}, \cr
\code{\link[=castForImport]{castForImport()}}
}
